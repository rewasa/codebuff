{"sha":"26140c86a06d66f531c17146d969be30957ef1fc","spec":"Implement hash-based navigation with proper browser history support for documentation section links. The system should:\n\n1. **Update browser history when clicking section headings**: When a user clicks on any heading (h1-h4) in the documentation, the browser URL should be updated to include the section hash (e.g., `#section-name`) using `history.pushState()`, followed by smooth scrolling to that section.\n\n2. **Handle hash navigation on page load and browser navigation**: \n   - When a page loads with a hash in the URL, automatically scroll smoothly to the target element\n   - When users use browser back/forward buttons that change the hash, smoothly scroll to the corresponding section\n   - Listen for `hashchange` events and respond appropriately\n\n3. **Maintain existing smooth scrolling behavior**: All scrolling to sections should use `{ behavior: 'smooth' }` for a polished user experience.\n\n4. **Apply consistently across components**: The hash navigation behavior should work in:\n   - The main documentation layout component\n   - Copy-enabled headings component  \n   - MDX heading components (h1, h2, h3, h4)\n\n5. **Preserve existing functionality**: All current features like copying links to sections, mobile responsive behavior, and heading styling should remain unchanged.\n\nThe implementation should ensure that documentation section links work seamlessly with browser navigation controls, allowing users to bookmark specific sections and use back/forward buttons to navigate between sections within the same page.","fileStates":[{"path":"web/src/app/docs/layout.tsx","preContent":"'use client'\n\nimport { Menu } from 'lucide-react'\nimport { usePathname } from 'next/navigation'\nimport { useState } from 'react'\n\nimport { DocSidebar, sections } from '@/components/docs/doc-sidebar'\nimport { Button } from '@/components/ui/button'\nimport { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet'\n\nexport default function DocsLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const pathname = usePathname()\n  const [open, setOpen] = useState(false)\n  return (\n    <div className=\"pt-8\">\n      <div className=\"container flex md:space-x-8 overflow-x-hidden\">\n        <DocSidebar\n          className=\"hidden lg:block w-64 shrink-0 sticky top-[24px] h-[calc(100vh-24px)] overflow-y-auto pr-4\"\n          onNavigate={() => setOpen(false)}\n        />\n        <main className=\"flex-1 mx-auto pb-36 md:px-8 min-w-0\">{children}</main>\n      </div>\n      <div className=\"flex items-center lg:hidden sticky bottom-0 z-50 bg-background/80 backdrop-blur-sm container p-4 rounded-t-lg border-t\">\n        <Sheet\n          open={open}\n          onOpenChange={(isOpen) => {\n            setOpen(isOpen)\n            if (!open) {\n              document.body.style.position = ''\n              document.body.style.overflow = ''\n              document.body.style.top = ''\n            }\n          }}\n        >\n          <SheetTrigger asChild>\n            <Button variant=\"ghost\" size=\"icon\" className=\"mr-4\">\n              <Menu className=\"h-5 w-5\" />\n              <span className=\"sr-only\">Toggle menu</span>\n            </Button>\n          </SheetTrigger>\n          <SheetContent\n            side=\"bottom\"\n            className=\"h-[80vh] p-6 pt-12 overflow-y-auto\"\n          >\n            <DocSidebar onNavigate={() => setOpen(false)} />\n          </SheetContent>\n          <SheetTrigger asChild>\n            <h1 className=\"text-xl font-semibold w-full\">\n              {sections.find((section) => pathname.startsWith(section.href))\n                ?.title || 'Documentation'}\n            </h1>\n          </SheetTrigger>\n        </Sheet>\n      </div>\n    </div>\n  )\n}\n","postContent":"'use client'\n\nimport { Menu } from 'lucide-react'\nimport { usePathname } from 'next/navigation'\nimport { useState, useEffect } from 'react'\n\nimport { DocSidebar, sections } from '@/components/docs/doc-sidebar'\nimport { Button } from '@/components/ui/button'\nimport { Sheet, SheetContent, SheetTrigger } from '@/components/ui/sheet'\n\nexport default function DocsLayout({\n  children,\n}: {\n  children: React.ReactNode\n}) {\n  const pathname = usePathname()\n  const [open, setOpen] = useState(false)\n\n  // New: Smoothly scroll to hash target on back/forward navigation\n  useEffect(() => {\n    const handleHashChange = () => {\n      const id = window.location.hash.slice(1)\n      if (id) {\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n      }\n    }\n\n    // If landing with a hash, ensure smooth scroll to target\n    handleHashChange()\n\n    window.addEventListener('hashchange', handleHashChange)\n    return () => window.removeEventListener('hashchange', handleHashChange)\n  }, [])\n\n  return (\n    <div className=\"pt-8\">\n      <div className=\"container flex md:space-x-8 overflow-x-hidden\">\n        <DocSidebar\n          className=\"hidden lg:block w-64 shrink-0 sticky top-[24px] h-[calc(100vh-24px)] overflow-y-auto pr-4\"\n          onNavigate={() => setOpen(false)}\n        />\n        <main className=\"flex-1 mx-auto pb-36 md:px-8 min-w-0\">{children}</main>\n      </div>\n      <div className=\"flex items-center lg:hidden sticky bottom-0 z-50 bg-background/80 backdrop-blur-sm container p-4 rounded-t-lg border-t\">\n        <Sheet\n          open={open}\n          onOpenChange={(isOpen) => {\n            setOpen(isOpen)\n            if (!open) {\n              document.body.style.position = ''\n              document.body.style.overflow = ''\n              document.body.style.top = ''\n            }\n          }}\n        >\n          <SheetTrigger asChild>\n            <Button variant=\"ghost\" size=\"icon\" className=\"mr-4\">\n              <Menu className=\"h-5 w-5\" />\n              <span className=\"sr-only\">Toggle menu</span>\n            </Button>\n          </SheetTrigger>\n          <SheetContent\n            side=\"bottom\"\n            className=\"h-[80vh] p-6 pt-12 overflow-y-auto\"\n          >\n            <DocSidebar onNavigate={() => setOpen(false)} />\n          </SheetContent>\n          <SheetTrigger asChild>\n            <h1 className=\"text-xl font-semibold w-full\">\n              {sections.find((section) => pathname.startsWith(section.href))\n                ?.title || 'Documentation'}\n            </h1>\n          </SheetTrigger>\n        </Sheet>\n      </div>\n    </div>\n  )\n}\n"},{"path":"web/src/components/docs/copy-heading.tsx","preContent":"'use client'\n\nimport { Check, Link } from 'lucide-react'\nimport React, { useState, useEffect } from 'react'\n\nimport type { HTMLAttributes } from 'react'\n\nexport function CopyHeading({\n  children,\n  ...props\n}: HTMLAttributes<HTMLHeadingElement>) {\n  const [copied, setCopied] = useState(false)\n\n  useEffect(() => {\n    if (copied) {\n      const t = setTimeout(() => setCopied(false), 2000)\n      return () => clearTimeout(t)\n    }\n    return undefined\n  }, [copied])\n\n  const title = children?.toString()\n  const id = title?.toLowerCase().replace(/\\s+/g, '-')\n  if (!title) return null\n\n  return (\n    <div className=\"group\">\n      <h1\n        {...props}\n        id={id}\n        className=\"inline-block hover:cursor-pointer hover:underline -mb-4 scroll-mt-24 font-serif\"\n        onClick={() =>\n          id &&\n          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n        }\n      >\n        {title}\n        <button\n          onClick={(e) => {\n            e.stopPropagation()\n            if (!id) return\n            const url = `${window.location.pathname}#${id}`\n            window.navigator.clipboard.writeText(window.location.origin + url)\n            setCopied(true)\n          }}\n          className=\"xs:opacity-100 xl:opacity-0 group-hover:opacity-100 p-2 rounded-full transition-opacity duration-300 ease-in-out\"\n          aria-label=\"Copy link to section\"\n        >\n          {copied ? (\n            <Check className=\"text-green-500 h-5 w-5\" />\n          ) : (\n            <Link className=\"h-5 w-5\" />\n          )}\n        </button>\n      </h1>\n    </div>\n  )\n}\n","postContent":"'use client'\n\nimport { Check, Link } from 'lucide-react'\nimport React, { useState, useEffect } from 'react'\n\nimport type { HTMLAttributes } from 'react'\n\nexport function CopyHeading({\n  children,\n  ...props\n}: HTMLAttributes<HTMLHeadingElement>) {\n  const [copied, setCopied] = useState(false)\n\n  useEffect(() => {\n    if (copied) {\n      const t = setTimeout(() => setCopied(false), 2000)\n      return () => clearTimeout(t)\n    }\n    return undefined\n  }, [copied])\n\n  const title = children?.toString()\n  const id = title?.toLowerCase().replace(/\\s+/g, '-')\n  if (!title) return null\n\n  return (\n    <div className=\"group\">\n      <h1\n        {...props}\n        id={id}\n        className=\"inline-block hover:cursor-pointer hover:underline -mb-4 scroll-mt-24 font-serif\"\n        onClick={() => {\n          if (!id) return\n          history.pushState(null, '', `${window.location.pathname}#${id}`)\n          document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n        }}\n      >\n        {title}\n        <button\n          onClick={(e) => {\n            e.stopPropagation()\n            if (!id) return\n            const url = `${window.location.pathname}#${id}`\n            window.navigator.clipboard.writeText(window.location.origin + url)\n            setCopied(true)\n          }}\n          className=\"xs:opacity-100 xl:opacity-0 group-hover:opacity-100 p-2 rounded-full transition-opacity duration-300 ease-in-out\"\n          aria-label=\"Copy link to section\"\n        >\n          {copied ? (\n            <Check className=\"text-green-500 h-5 w-5\" />\n          ) : (\n            <Link className=\"h-5 w-5\" />\n          )}\n        </button>\n      </h1>\n    </div>\n  )\n}\n"},{"path":"web/src/components/docs/mdx/mdx-components.tsx","preContent":"import { Check, Link } from 'lucide-react'\nimport Image from 'next/image'\nimport { useMDXComponent } from 'next-contentlayer/hooks'\nimport React, { useState, useEffect } from 'react'\n\nimport { CodeDemo } from './code-demo'\nimport { MarkdownTable } from './markdown-table'\nimport { AgentTemplateSchemaDisplay, SchemaDisplay } from './schema-display'\n\nimport type {\n  HTMLAttributes,\n  AnchorHTMLAttributes,\n  ImgHTMLAttributes,\n} from 'react'\n\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { cn } from '@/lib/utils'\n\ninterface MdxProps {\n  code: string\n}\n\n// Helper function to create heading components with copy link functionality\nconst createHeadingWithCopyLink = (\n  HeadingComponent: 'h1' | 'h2' | 'h3' | 'h4',\n  defaultClasses: string\n) => {\n  const HeadingWithCopyLink = ({\n    className,\n    children,\n    ...props\n  }: HTMLAttributes<HTMLHeadingElement>) => {\n    const [copied, setCopied] = useState(false)\n    const [showCopyButton, setShowCopyButton] = useState(false)\n    const isMobile = useIsMobile()\n\n    useEffect(() => {\n      if (copied) {\n        const timer = setTimeout(() => setCopied(false), 2000)\n        return () => clearTimeout(timer)\n      }\n      return undefined\n    }, [copied])\n\n    // Auto-hide copy button on mobile after 3 seconds\n    useEffect(() => {\n      if (isMobile && showCopyButton) {\n        const timer = setTimeout(() => setShowCopyButton(false), 1_500)\n        return () => clearTimeout(timer)\n      }\n      return undefined\n    }, [isMobile, showCopyButton])\n\n    const title = children?.toString()\n\n    // Generate hierarchical ID by including heading level context\n    const generateHierarchicalId = (text: string, level: string) => {\n      const baseId = text\n        ?.toLowerCase()\n        .replace(/\\s+/g, '-')\n        .replace(/[^\\w-]/g, '')\n\n      // Use heading level to create meaningful hierarchy\n      const levelNum = parseInt(level.replace('h', ''))\n\n      // For h1, use as-is. For h2+, prefix with level to ensure uniqueness\n      // This creates URLs like: #overview (h1), #h2-overview (h2), etc.\n      return levelNum === 1 ? baseId : `${level}-${baseId}`\n    }\n\n    const id = title\n      ? generateHierarchicalId(title, HeadingComponent)\n      : undefined\n\n    if (!title) {\n      return (\n        <HeadingComponent\n          {...props}\n          className={cn(\n            'group relative hover:cursor-pointer hover:underline scroll-m-20',\n            defaultClasses,\n            className\n          )}\n        >\n          {children}\n        </HeadingComponent>\n      )\n    }\n\n    const handleCopy = (e: React.MouseEvent) => {\n      e.stopPropagation()\n      if (!id) return\n      const url = `${window.location.pathname}#${id}`\n      window.navigator.clipboard.writeText(window.location.origin + url)\n      setCopied(true)\n    }\n\n    const handleClick = () => {\n      if (id) {\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n      }\n\n      // On mobile, toggle copy button visibility when title is tapped\n      if (isMobile) {\n        setShowCopyButton(!showCopyButton)\n      }\n    }\n\n    // Determine button visibility based on device type\n    const buttonVisibilityClass = isMobile\n      ? showCopyButton\n        ? 'opacity-100'\n        : 'opacity-0'\n      : 'xs:opacity-100 xl:opacity-0 group-hover:opacity-100'\n\n    return (\n      <div className=\"group\">\n        <HeadingComponent\n          {...props}\n          id={id}\n          className={cn(\n            'hover:cursor-pointer hover:underline scroll-m-20 inline-flex items-center gap-2',\n            defaultClasses,\n            className\n          )}\n          onClick={handleClick}\n        >\n          {children}\n          <button\n            onClick={handleCopy}\n            className={cn(\n              buttonVisibilityClass,\n              'p-1.5 rounded-md bg-muted/50 hover:bg-muted border border-border/50 hover:border-border transition-all duration-200 ease-in-out inline-flex items-center justify-center shadow-sm hover:shadow-md',\n              isMobile ? 'min-h-[44px] min-w-[44px]' : 'h-auto w-auto'\n            )}\n            aria-label=\"Copy link to section\"\n          >\n            {copied ? (\n              <Check className=\"text-green-500 h-4 w-4\" />\n            ) : (\n              <Link className=\"h-4 w-4 text-muted-foreground hover:text-foreground\" />\n            )}\n          </button>\n        </HeadingComponent>\n      </div>\n    )\n  }\n\n  return HeadingWithCopyLink\n}\n\nconst components = {\n  a: ({ className, ...props }: AnchorHTMLAttributes<HTMLAnchorElement>) => (\n    <a\n      className={cn(\n        'text-primary underline underline-offset-4 hover:no-underline font-medium',\n        className\n      )}\n      {...props}\n    />\n  ),\n  h1: createHeadingWithCopyLink(\n    'h1',\n    'mt-6 text-3xl font-semibold tracking-tight first:mt-0 first:mb-0'\n  ),\n  h2: createHeadingWithCopyLink(\n    'h2',\n    'mt-8 text-2xl font-semibold tracking-tight'\n  ),\n  h3: createHeadingWithCopyLink(\n    'h3',\n    'mt-6 text-xl font-semibold tracking-tight'\n  ),\n  h4: createHeadingWithCopyLink(\n    'h4',\n    'mt-4 text-lg font-semibold tracking-tight'\n  ),\n  p: ({ className, ...props }: HTMLAttributes<HTMLParagraphElement>) => (\n    <p\n      className={cn('leading-7 mt-2 mb-3 text-muted-foreground', className)}\n      {...props}\n    />\n  ),\n  ul: ({ className, ...props }: HTMLAttributes<HTMLUListElement>) => (\n    <ul className={cn('my-4 ml-6 list-disc', className)} {...props} />\n  ),\n  ol: ({ className, ...props }: HTMLAttributes<HTMLOListElement>) => (\n    <ol className={cn('my-4 ml-6 list-decimal', className)} {...props} />\n  ),\n  li: ({ className, ...props }: HTMLAttributes<HTMLLIElement>) => (\n    <li className={cn('mt-2', className)} {...props} />\n  ),\n  blockquote: ({ className, ...props }: HTMLAttributes<HTMLQuoteElement>) => (\n    <blockquote\n      className={cn(\n        'mt-4 border-l-2 pl-4 italic text-muted-foreground',\n        className\n      )}\n      {...props}\n    />\n  ),\n  img: ({ className, alt, ...props }: ImgHTMLAttributes<HTMLImageElement>) => (\n    // eslint-disable-next-line @next/next/no-img-element\n    <img className={cn('rounded-md', className)} alt={alt} {...props} />\n  ),\n  hr: ({ ...props }) => <hr className=\"my-4 md:my-6\" {...props} />,\n  table: ({ className, ...props }: HTMLAttributes<HTMLTableElement>) => (\n    <div className=\"my-6 w-full overflow-x-auto\">\n      <table className={cn('w-full', className)} {...props} />\n    </div>\n  ),\n  tr: ({ className, ...props }: HTMLAttributes<HTMLTableRowElement>) => (\n    <tr\n      className={cn('m-0 border-t p-0 even:bg-muted', className)}\n      {...props}\n    />\n  ),\n  th: ({ className, ...props }: HTMLAttributes<HTMLTableCellElement>) => (\n    <th\n      className={cn(\n        'border px-4 py-2 text-left font-bold [&[align=center]]:text-center [&[align=right]]:text-right',\n        className\n      )}\n      {...props}\n    />\n  ),\n  td: ({ className, ...props }: HTMLAttributes<HTMLTableCellElement>) => (\n    <td\n      className={cn(\n        'border px-4 py-2 text-left [&[align=center]]:text-center [&[align=right]]:text-right',\n        className\n      )}\n      {...props}\n    />\n  ),\n  pre: ({ className, ...props }: HTMLAttributes<HTMLPreElement>) => (\n    <pre\n      className={cn(\n        'mb-4 mt-4 overflow-x-auto rounded-lg border bg-black/5 dark:bg-white/5 py-4',\n        className\n      )}\n      {...props}\n    />\n  ),\n  code: ({ className, ...props }: HTMLAttributes<HTMLElement>) => (\n    <code\n      className={cn(\n        'relative rounded px-[0.3rem] py-[0.2rem] font-mono text-sm bg-muted',\n        className\n      )}\n      {...props}\n    />\n  ),\n  Image,\n  CodeDemo,\n  MarkdownTable,\n  SchemaDisplay,\n  AgentTemplateSchemaDisplay,\n}\n\nexport function Mdx({ code }: MdxProps) {\n  const Component = useMDXComponent(code)\n  return <Component components={components} />\n}\n","postContent":"import { Check, Link } from 'lucide-react'\nimport Image from 'next/image'\nimport { useMDXComponent } from 'next-contentlayer/hooks'\nimport React, { useState, useEffect } from 'react'\n\nimport { CodeDemo } from './code-demo'\nimport { MarkdownTable } from './markdown-table'\nimport { AgentTemplateSchemaDisplay, SchemaDisplay } from './schema-display'\n\nimport type {\n  HTMLAttributes,\n  AnchorHTMLAttributes,\n  ImgHTMLAttributes,\n} from 'react'\n\nimport { useIsMobile } from '@/hooks/use-mobile'\nimport { cn } from '@/lib/utils'\n\ninterface MdxProps {\n  code: string\n}\n\n// Helper function to create heading components with copy link functionality\nconst createHeadingWithCopyLink = (\n  HeadingComponent: 'h1' | 'h2' | 'h3' | 'h4',\n  defaultClasses: string\n) => {\n  const HeadingWithCopyLink = ({\n    className,\n    children,\n    ...props\n  }: HTMLAttributes<HTMLHeadingElement>) => {\n    const [copied, setCopied] = useState(false)\n    const [showCopyButton, setShowCopyButton] = useState(false)\n    const isMobile = useIsMobile()\n\n    useEffect(() => {\n      if (copied) {\n        const timer = setTimeout(() => setCopied(false), 2000)\n        return () => clearTimeout(timer)\n      }\n      return undefined\n    }, [copied])\n\n    // Auto-hide copy button on mobile after 3 seconds\n    useEffect(() => {\n      if (isMobile && showCopyButton) {\n        const timer = setTimeout(() => setShowCopyButton(false), 1_500)\n        return () => clearTimeout(timer)\n      }\n      return undefined\n    }, [isMobile, showCopyButton])\n\n    const title = children?.toString()\n\n    // Generate hierarchical ID by including heading level context\n    const generateHierarchicalId = (text: string, level: string) => {\n      const baseId = text\n        ?.toLowerCase()\n        .replace(/\\s+/g, '-')\n        .replace(/[^\\w-]/g, '')\n\n      // Use heading level to create meaningful hierarchy\n      const levelNum = parseInt(level.replace('h', ''))\n\n      // For h1, use as-is. For h2+, prefix with level to ensure uniqueness\n      // This creates URLs like: #overview (h1), #h2-overview (h2), etc.\n      return levelNum === 1 ? baseId : `${level}-${baseId}`\n    }\n\n    const id = title\n      ? generateHierarchicalId(title, HeadingComponent)\n      : undefined\n\n    if (!title) {\n      return (\n        <HeadingComponent\n          {...props}\n          className={cn(\n            'group relative hover:cursor-pointer hover:underline scroll-m-20',\n            defaultClasses,\n            className\n          )}\n        >\n          {children}\n        </HeadingComponent>\n      )\n    }\n\n    const handleCopy = (e: React.MouseEvent) => {\n      e.stopPropagation()\n      if (!id) return\n      const url = `${window.location.pathname}#${id}`\n      window.navigator.clipboard.writeText(window.location.origin + url)\n      setCopied(true)\n    }\n\n    const handleClick = () => {\n      if (id) {\n        // Add a history entry with the new hash and smoothly scroll\n        history.pushState(null, '', `${window.location.pathname}#${id}`)\n        document.getElementById(id)?.scrollIntoView({ behavior: 'smooth' })\n      }\n\n      // On mobile, toggle copy button visibility when title is tapped\n      if (isMobile) {\n        setShowCopyButton(!showCopyButton)\n      }\n    }\n\n    // Determine button visibility based on device type\n    const buttonVisibilityClass = isMobile\n      ? showCopyButton\n        ? 'opacity-100'\n        : 'opacity-0'\n      : 'xs:opacity-100 xl:opacity-0 group-hover:opacity-100'\n\n    return (\n      <div className=\"group\">\n        <HeadingComponent\n          {...props}\n          id={id}\n          className={cn(\n            'hover:cursor-pointer hover:underline scroll-m-20 inline-flex items-center gap-2',\n            defaultClasses,\n            className\n          )}\n          onClick={handleClick}\n        >\n          {children}\n          <button\n            onClick={handleCopy}\n            className={cn(\n              buttonVisibilityClass,\n              'p-1.5 rounded-md bg-muted/50 hover:bg-muted border border-border/50 hover:border-border transition-all duration-200 ease-in-out inline-flex items-center justify-center shadow-sm hover:shadow-md',\n              isMobile ? 'min-h-[44px] min-w-[44px]' : 'h-auto w-auto'\n            )}\n            aria-label=\"Copy link to section\"\n          >\n            {copied ? (\n              <Check className=\"text-green-500 h-4 w-4\" />\n            ) : (\n              <Link className=\"h-4 w-4 text-muted-foreground hover:text-foreground\" />\n            )}\n          </button>\n        </HeadingComponent>\n      </div>\n    )\n  }\n\n  return HeadingWithCopyLink\n}\n\nconst components = {\n  a: ({ className, ...props }: AnchorHTMLAttributes<HTMLAnchorElement>) => (\n    <a\n      className={cn(\n        'text-primary underline underline-offset-4 hover:no-underline font-medium',\n        className\n      )}\n      {...props}\n    />\n  ),\n  h1: createHeadingWithCopyLink(\n    'h1',\n    'mt-6 text-3xl font-semibold tracking-tight first:mt-0 first:mb-0'\n  ),\n  h2: createHeadingWithCopyLink(\n    'h2',\n    'mt-8 text-2xl font-semibold tracking-tight'\n  ),\n  h3: createHeadingWithCopyLink(\n    'h3',\n    'mt-6 text-xl font-semibold tracking-tight'\n  ),\n  h4: createHeadingWithCopyLink(\n    'h4',\n    'mt-4 text-lg font-semibold tracking-tight'\n  ),\n  p: ({ className, ...props }: HTMLAttributes<HTMLParagraphElement>) => (\n    <p\n      className={cn('leading-7 mt-2 mb-3 text-muted-foreground', className)}\n      {...props}\n    />\n  ),\n  ul: ({ className, ...props }: HTMLAttributes<HTMLUListElement>) => (\n    <ul className={cn('my-4 ml-6 list-disc', className)} {...props} />\n  ),\n  ol: ({ className, ...props }: HTMLAttributes<HTMLOListElement>) => (\n    <ol className={cn('my-4 ml-6 list-decimal', className)} {...props} />\n  ),\n  li: ({ className, ...props }: HTMLAttributes<HTMLLIElement>) => (\n    <li className={cn('mt-2', className)} {...props} />\n  ),\n  blockquote: ({ className, ...props }: HTMLAttributes<HTMLQuoteElement>) => (\n    <blockquote\n      className={cn(\n        'mt-4 border-l-2 pl-4 italic text-muted-foreground',\n        className\n      )}\n      {...props}\n    />\n  ),\n  img: ({ className, alt, ...props }: ImgHTMLAttributes<HTMLImageElement>) => (\n    // eslint-disable-next-line @next/next/no-img-element\n    <img className={cn('rounded-md', className)} alt={alt} {...props} />\n  ),\n  hr: ({ ...props }) => <hr className=\"my-4 md:my-6\" {...props} />,\n  table: ({ className, ...props }: HTMLAttributes<HTMLTableElement>) => (\n    <div className=\"my-6 w-full overflow-x-auto\">\n      <table className={cn('w-full', className)} {...props} />\n    </div>\n  ),\n  tr: ({ className, ...props }: HTMLAttributes<HTMLTableRowElement>) => (\n    <tr\n      className={cn('m-0 border-t p-0 even:bg-muted', className)}\n      {...props}\n    />\n  ),\n  th: ({ className, ...props }: HTMLAttributes<HTMLTableCellElement>) => (\n    <th\n      className={cn(\n        'border px-4 py-2 text-left font-bold [&[align=center]]:text-center [&[align=right]]:text-right',\n        className\n      )}\n      {...props}\n    />\n  ),\n  td: ({ className, ...props }: HTMLAttributes<HTMLTableCellElement>) => (\n    <td\n      className={cn(\n        'border px-4 py-2 text-left [&[align=center]]:text-center [&[align=right]]:text-right',\n        className\n      )}\n      {...props}\n    />\n  ),\n  pre: ({ className, ...props }: HTMLAttributes<HTMLPreElement>) => (\n    <pre\n      className={cn(\n        'mb-4 mt-4 overflow-x-auto rounded-lg border bg-black/5 dark:bg-white/5 py-4',\n        className\n      )}\n      {...props}\n    />\n  ),\n  code: ({ className, ...props }: HTMLAttributes<HTMLElement>) => (\n    <code\n      className={cn(\n        'relative rounded px-[0.3rem] py-[0.2rem] font-mono text-sm bg-muted',\n        className\n      )}\n      {...props}\n    />\n  ),\n  Image,\n  CodeDemo,\n  MarkdownTable,\n  SchemaDisplay,\n  AgentTemplateSchemaDisplay,\n}\n\nexport function Mdx({ code }: MdxProps) {\n  const Component = useMDXComponent(code)\n  return <Component components={components} />\n}\n"},{"path":"web/src/content/advanced/claude-code-comparison.mdx","preContent":"---\ntitle: 'Codebuff vs Claude Code'\nsection: 'advanced'\ntags: ['comparison', 'claude code']\norder: 5\n---\n\n# Codebuff vs Claude Code\n\nAnthropic recently released Claude Code, their own AI coding assistant.\n\nBoth Codebuff and Claude Code:\n\n- Run in your terminal for a seamless coding experience\n- Understand your entire codebase context\n- Can edit files and execute terminal commands\n- Use Claude Sonnet as their primary model\n\n## When to Choose Codebuff\n\nCodebuff might be a better choice if you value:\n\n- Speed: Codebuff is [nearly 4 times faster](https://x.com/jahooma/status/1894224663817195599)\n- Cost: Codebuff is one third the cost of Claude Code for equivalent tasks and even less for back-and-forth conversation\n- Codebase Analysis: Codebuff pulls more context from scanning your entire codebase, rather than file-by-file. Codebuff also [blends different models](/docs/advanced#what-models-do-you-use) based on their strengths to provide more accurate results.\n- Staying in Flow: Codebuff requires fewer confirmation prompts for file edits and command execution.\n- Focused changes: Codebuff does just what you asked for, while Claude Code will often get carried away editing more and more files.\n\n## When to Choose Claude Code\n\nClaude Code might be a better choice if you:\n\n- Can't use an intermediary provider, need to use the API directly from Anthropic\n\n## Feature Comparison\n\n<MarkdownTable>\n  | Feature | Codebuff | Claude Code | | --- | --- | --- | | CLI-based\n  interaction | ‚úÖ | ‚úÖ | | Natural language commands | ‚úÖ | ‚úÖ | | Autonomous\n  test execution | ‚úÖ | ‚úÖ | | Deep, targeted context awareness | ‚úÖ | ‚ùå | |\n  Large context window | ‚úÖ¬†(200k - 1M) | ‚úÖ¬†(200k) | | Fast diff edits (no full\n  rewrites) | ‚úÖ | ‚ùå | | Accuracy at scale | ‚úÖ | ‚ùå | | Cost | $ | $$$ | |\n  Polished UI | ‚ùå | ‚úÖ | | Minimal interruptions | ‚úÖ | ‚ùå |\n</MarkdownTable>\n\n## Summary\n\nBoth Codebuff and Claude Code are powerful AI coding assistants that can significantly boost your productivity. Codebuff offers more flexible pricing and performance options, while Claude Code provides direct integration with Anthropic's ecosystem.\n","postContent":"---\ntitle: 'Codebuff vs Claude Code'\nsection: 'advanced'\ntags: ['comparison', 'claude code']\norder: 5\n---\n\n# Codebuff vs Claude Code\n\nAnthropic recently released Claude Code, their own AI coding assistant.\n\nBoth Codebuff and Claude Code:\n\n- Run in your terminal for a seamless coding experience\n- Understand your entire codebase context\n- Can edit files and execute terminal commands\n- Use Claude Sonnet as their primary model\n\n## When to Choose Codebuff\n\nCodebuff might be a better choice if you value:\n\n- Speed: Codebuff is [nearly 4 times faster](https://x.com/jahooma/status/1894224663817195599)\n- Cost: Codebuff is one third the cost of Claude Code for equivalent tasks and even less for back-and-forth conversation\n- Codebase Analysis: Codebuff pulls more context from scanning your entire codebase, rather than file-by-file. Codebuff also [blends different models](/docs/advanced#what-models-do-you-use) based on their strengths to provide more accurate results.\n- Staying in Flow: Codebuff requires fewer confirmation prompts for file edits and command execution.\n- Focused changes: Codebuff does just what you asked for, while Claude Code will often get carried away editing more and more files.\n- SDK and Programmatic Access: Codebuff provides a full TypeScript SDK for programmatic integration, allowing you to create custom workflows and embed AI coding capabilities into your own tools.\n- Advanced Agent System: Create custom agents with TypeScript generator functions, spawn subagents, and orchestrate complex multi-step workflows that go far beyond simple chat interactions.\n\n## When to Choose Claude Code\n\nClaude Code might be a better choice if you:\n\n- You require first-party Anthropic integration (no intermediary/proxy) for procurement, data handling, or legal reasons\n- You need enterprise security/compliance controls directly from Anthropic (e.g., SOC 2/ISO programs, data-retention controls, private/VPC networking options)\n- Your org needs centralized admin controls within Anthropic's ecosystem (SSO, RBAC, governance, auditability)\n- You prioritize early access to Anthropic model capabilities and first-party tooling\n\n\n## Feature Comparison\n\n<MarkdownTable>\n| Feature | Codebuff | Claude Code |\n| --- | --- | --- |\n| CLI-based interaction | ‚úÖ | ‚úÖ |\n| Natural language commands | ‚úÖ | ‚úÖ |\n| Autonomous test execution | ‚úÖ | ‚úÖ |\n| Large context window | ‚úÖ (200k-1M) | ‚úÖ (200k-1M) |\n| Directory-specific context awareness | ‚úÖ | üîÑ |\n| Fast diff edits (no full rewrites) | ‚úÖ | ‚ùå |\n| Cost | $ | $$ |\n| Polished UI | ‚ùå | ‚úÖ |\n| Minimal interruptions | ‚úÖ | ‚ùå |\n| Full-featured SDK | ‚úÖ | ‚ùå |\n| Programmatic agent creation | ‚úÖ | ‚ùå |\n| Project templates | ‚úÖ | ‚ùå |\n</MarkdownTable>\n\n## Summary\n\nBoth Codebuff and Claude Code are powerful AI coding assistants that can significantly boost your productivity. Codebuff offers more flexible pricing and performance options, while Claude Code provides direct integration with Anthropic's ecosystem.\n"},{"path":"web/src/content/agents/creating-new-agents.mdx","preContent":"---\ntitle: 'Creating New Agents'\nsection: 'advanced'\ntags: ['customization', 'agent templates', 'agents']\norder: 2\n---\n\n# Creating New Agents\n\nCreate specialized agents from scratch using TypeScript files in the `.agents/` directory.\n\n**Types:**\n\n- **LLM-based** - Use prompts and language models\n- **Programmatic** - Use TypeScript generator functions with `handleSteps`\n\n## Basic Structure\n\nCreate a new TypeScript file in `.agents/` directory:\n\n**.agents/code-analyzer.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"code-analyzer\",\n  displayName: \"Code Analysis Expert\",\n  spawnerPrompt: \"Spawn for deep code analysis and refactoring suggestions\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n\n  toolNames: [\"read_files\", \"code_search\", \"spawn_agents\", \"write_file\"],\n  spawnableAgents: [\"codebuff/thinker@0.0.1\", \"codebuff/reviewer@0.0.1\"],\n\n  handleSteps: function* ({ agentState, prompt, params }) {\n    // First, find relevant files\n    const { toolResult: files } = yield {\n      toolName: 'find_files',\n      input: { query: prompt }\n    }\n\n    // Read the most important files\n    if (files) {\n      const filePaths = JSON.parse(files).slice(0, 5)\n\n      const { toolResult } = yield {\n        toolName: 'read_files',\n        input: { paths: ['file1.ts', 'file2.ts'] }\n      }\n    }\n\n    // Spawn a thinker for deep analysis\n    yield {\n      toolName: 'spawn_agents',\n      input: {\n        agents: [{\n          agent_type: 'thinker',\n          prompt: `Analyze the code structure and suggest improvements for: ${prompt}`\n        }]\n      }\n    }\n\n    // Let the agent generate its response\n    yield 'STEP_ALL'\n\nexport default definition\n```\n\n```\n\n**Control Flow:**\n- `yield 'STEP'` - Run one LLM generation step\n- `yield 'STEP_ALL'` - Run until completion\n- `return` - End the agent's turn\n\n**Accessing Context:**\n- `agentState` - Current agent state and message history\n- `prompt` - User's prompt to the agent\n- `params` - Additional parameters passed to the agent\n# Creating New Agents\nCreate specialized agents from scratch using TypeScript files in the `.agents/` directory.\n**Types:**\n\n- **LLM-based** - Use prompts and language models\n- **Programmatic** - Use TypeScript generator functions with `handleSteps`\n\n## Basic Structure\n\nCreate a new TypeScript file in `.agents/` directory:\n\n**.agents/my-custom-agent.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"my-custom-agent\",\n  version: \"1.0.0\",\n\n\n  displayName: \"My Custom Agent\",\n  spawnerPrompt: \"Spawn this agent for specialized workflow tasks requiring custom logic\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n  toolNames: [\"read_files\", \"write_file\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/researcher@0.0.1\"],  // Use full name for built-in agents\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"What documentation to create or update\"\n    }\n  },\n\n  systemPrompt: `You are a documentation specialist.`,\n  instructionsPrompt: \"Create comprehensive documentation based on the user's request. Research existing code and patterns first.\",\n  stepPrompt: \"Continue working on the documentation. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n**.agents/templates/doc-writer-system.md**\n\n```markdown\n# Documentation Writer\n\nCreate clear, comprehensive documentation for codebases.\n\n## Guidelines\n\n- Research codebase first\n- Use clear, concise language\n- Include practical examples\n- Test examples for accuracy\n```\n\n## More Domain-Specific Examples\n\n### API Documentation Agent\n\nSpecialized for documenting REST APIs and GraphQL schemas:\n\n**.agents/api-documenter.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"api-documenter\",\n  version: \"1.0.0\",\n\n\n  displayName: \"API Documentation Specialist\",\n  spawnerPrompt: \"Spawn this agent to create comprehensive API documentation with examples, schemas, and error codes\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\"read_files\", \"code_search\", \"write_file\", \"spawn_agents\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/researcher@0.0.1\"],  // Use full name for built-in agents\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"What API endpoints or schemas to document\"\n    }\n  },\n\n  systemPrompt: \"You are an API documentation specialist. Create clear, comprehensive documentation for REST APIs and GraphQL schemas with examples, request/response formats, and error codes.\",\n  instructionsPrompt: \"Analyze the specified API endpoints and create detailed documentation including examples, parameters, and response schemas.\",\n  stepPrompt: \"Continue documenting the API. Include practical examples and edge cases. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n### Database Migration Agent\n\nSpecialized for creating and reviewing database migrations:\n\n**.agents/migration-specialist.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"migration-specialist\",\n  version: \"1.0.0\",\n\n\n  displayName: \"Database Migration Specialist\",\n  spawnerPrompt: \"Spawn this agent to create safe, reversible database migrations with proper indexing and rollback procedures\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\n    \"read_files\",\n    \"write_file\",\n    \"code_search\",\n    \"run_terminal_command\",\n    \"end_turn\"\n  ],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\"],\n\n  systemPrompt: \"You are a database migration specialist. Your goal is to create safe, reversible database migrations with proper indexing and rollback procedures.\",\n  instructionsPrompt: \"Create a database migration for the requested schema changes. Ensure it's reversible and includes proper indexing.\",\n  stepPrompt: \"Continue working on the migration. Test it if possible and spawn a reviewer to check for issues.\"\n}\n\nexport default definition\n```\n**.agents/templates/migration-guidelines.md**\n\n```markdown\n# Database Migration Guidelines\n\n## Safety First\n\n- Always create reversible migrations (up and down)\n- Test migrations on a copy of production data\n- Add indexes for new foreign keys\n- Use transactions where supported\n\n## Performance Considerations\n\n- Avoid locking tables during peak hours\n- Use `ADD COLUMN` with defaults carefully\n- Consider batching large data changes\n- Monitor migration execution time\n\n## Best Practices\n\n- Include descriptive migration names\n- Add comments explaining complex changes\n- Validate data integrity after migration\n- Keep migrations atomic and focused\n```\n\n## Advanced Examples\n\n### Frontend Development Coordinator\n\n**.agents/frontend-coordinator.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"frontend-coordinator\",\n  version: \"1.0.0\",\n  displayName: \"Frontend Development Coordinator\",\n  spawnerPrompt: \"Spawn this agent to coordinate frontend development tasks with React best practices and component architecture\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n  toolNames: [\"read_files\", \"write_file\", \"code_search\", \"spawn_agents\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\", \"codebuff/researcher@0.0.1\", \"codebuff/file-picker@0.0.1\"],\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"Frontend development task to coordinate\"\n    }\n  },\n  systemPrompt: \"You are a frontend development coordinator specializing in React best practices. Guide development workflows and ensure code quality.\",\n  instructionsPrompt: \"Coordinate the frontend development task, spawning appropriate agents as needed.\",\n  stepPrompt: \"Continue coordinating the frontend development workflow. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n\n### API Development Specialist\n\n**.agents/api-specialist.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"api-specialist\",\n  version: \"1.0.0\",\n  displayName: \"API Development Specialist\",\n  spawnerPrompt: \"Spawn this agent for REST API development, OpenAPI compliance, and endpoint documentation\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n  toolNames: [\"read_files\", \"write_file\", \"code_search\", \"spawn_agents\", \"run_terminal_command\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\", \"codebuff/researcher@0.0.1\", \"codebuff/file-picker@0.0.1\"],\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"API development or documentation task\"\n    }\n  },\n  systemPrompt: \"You are an API development specialist focused on creating robust, well-documented REST APIs following industry standards.\",\n  instructionsPrompt: \"Handle the API development task, ensuring proper design patterns and documentation.\",\n  stepPrompt: \"Continue working on the API development task. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n\n### DevOps Automation Agent\n\n**.agents/devops-automator.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"devops-automator\",\n  version: \"1.0.0\",\n  displayName: \"DevOps Automation Specialist\",\n  spawnerPrompt: \"Spawn this agent for infrastructure automation, CI/CD pipelines, and deployment configuration\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n  toolNames: [\"read_files\", \"write_file\", \"code_search\", \"spawn_agents\", \"run_terminal_command\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\", \"codebuff/researcher@0.0.1\", \"codebuff/file-picker@0.0.1\"],\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"Infrastructure or deployment automation task\"\n    }\n  },\n  systemPrompt: \"You are a DevOps automation specialist focused on secure, scalable infrastructure and deployment pipelines.\",\n  instructionsPrompt: \"Handle the infrastructure or deployment automation task with security and reliability in mind.\",\n  stepPrompt: \"Continue working on the DevOps automation task. Use end_turn when complete.\"\n}export default definition\n```\n\n## Programmatic Agents (Advanced)\n\n**üéØ This is where Codebuff agents become truly powerful!** While LLM-based agents work well for many tasks, programmatic agents give you precise control over complex workflows.\n\n### Why Use Programmatic Agents?\n\n- **Deterministic workflows** - Guarantee specific steps happen in order\n- **Dynamic decision making** - Branch based on actual file contents or tool results\n- **Complex orchestration** - Coordinate multiple agents and tools with logic\n- **Error handling** - Catch and handle tool errors programmatically\n- **State management** - Maintain state across multiple agent steps\n\n### How It Works\n\nUse TypeScript generator functions with the `handleSteps` field to control execution:\n\n**.agents/code-analyzer.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"code-analyzer\",\n  displayName: \"Code Analysis Expert\",\n  spawnerPrompt: \"Spawn for deep code analysis and refactoring suggestions\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n\n  toolNames: [\"read_files\", \"code_search\", \"spawn_agents\", \"write_file\"],\n  spawnableAgents: [\"codebuff/thinker@0.0.1\", \"codebuff/reviewer@0.0.1\"],\n\n  handleSteps: function* ({ agentState, prompt, params }) {\n    // First, find relevant files\n    const { toolResult: files } = yield {\n      toolName: 'find_files',\n      input: { query: prompt }\n    }\n\n    // Read the most important files\n    if (files) {\n      const filePaths = JSON.parse(files).slice(0, 5)\n      yield {\n        toolName: 'read_files',\n        input: { paths: filePaths }\n      }\n    }\n\n    // Spawn a thinker for deep analysis\n    yield {\n      toolName: 'spawn_agents',\n      input: {\n        agents: [{\n          agent_type: 'thinker',\n          prompt: `Analyze the code structure and suggest improvements for: ${prompt}`\n        }]\n      }\n    }\n\n    // Let the agent generate its response\n    yield 'STEP_ALL'\n  }\n}\n\nexport default definition\n```\n\n### Key Concepts for Programmatic Agents\n\n#### 1. Generator Function Basics\n\nYour `handleSteps` function receives context and yields actions:\n\n```typescript\nhandleSteps: function* ({ agentState, prompt, params }) {\n  // agentState - Current conversation and agent state\n  // prompt - What the user asked this agent to do\n  // params - Additional parameters passed to the agent\n\n  // Your logic here...\n}\n```\n\n#### 2. Yielding Tool Calls\n\nExecute tools and get their results:\n\n```typescript\nconst { toolResult, toolError } = yield {\n  toolName: 'read_files',\n  input: { paths: ['file1.ts', 'file2.ts'] }\n}\n\nif (toolError) {\n  // Handle error case\n  console.error('Failed to read files:', toolError)\n} else {\n  // Use the result\n  const fileContent = JSON.parse(toolResult)\n}\n```\n\n#### 3. Control Flow Options\n\n| Command | Purpose | When to Use |\n|---------|---------|------------|\n| `yield 'STEP'` | Run one LLM generation | Need single response |\n| `yield 'STEP_ALL'` | Run until completion | Let LLM finish the task |\n| `return` | End immediately | Task complete or error |\n\n#### 4. Advanced Example: Conditional Workflow\n\n```typescript\nhandleSteps: function* ({ agentState, prompt, params }) {\n  // Step 1: Analyze the codebase\n  const { toolResult: analysis } = yield {\n    toolName: 'spawn_agents',\n    input: {\n      agents: [{\n        agent_type: 'thinker',\n        prompt: `Analyze: ${prompt}`\n      }]\n    }\n  }\n\n  // Step 2: Based on analysis, choose action\n  if (analysis?.includes('refactor')) {\n    // Get all files that need refactoring\n    const { toolResult: files } = yield {\n      toolName: 'find_files',\n      input: { query: 'needs refactoring' }\n    }\n\n    // Step 3: Refactor each file\n    for (const file of JSON.parse(files || '[]')) {\n      yield {\n        toolName: 'write_file',\n        input: {\n          path: file,\n          instructions: 'Refactor for better performance',\n          content: '// ... refactored code ...'\n        }\n      }\n    }\n  }\n\n  // Step 4: Final review\n  yield {\n    toolName: 'spawn_agents',\n    input: {\n      agents: [{\n        agent_type: 'reviewer',\n        prompt: 'Review all changes'\n      }]\n    }\n  }\n\n  // Let the agent summarize\n  yield 'STEP_ALL'\n}\n```\n\n### When to Choose Programmatic vs LLM-based\n\n**Use Programmatic (`handleSteps`) when:**\n- You need guaranteed execution order\n- Decisions depend on specific file contents\n- Complex multi-step workflows with branching\n- Integration with external systems\n- Error recovery is critical\n\n**Use LLM-based (prompts only) when:**\n- Task is straightforward\n- Agent needs creative freedom\n- Natural language understanding is key\n- Workflow is simple and linear\n\n```\n**.agents/prompts/doc-writer-system.md**\n}\n\n**.agents/prompts/migration-guidelines.md**\nYou can also reference external files for prompts:\n\n```typescript\nsystemPrompt: {\n  path: \"./prompts/doc-writer-system.md\"\n## Programmatic Agents\n**Coming Soon** - Use JavaScript/TypeScript for complex orchestration logic.\n## Best Practices\n1. **Start small** - Begin with simple agents before complex ones\n2. **Experiment** - Try different tool/prompt combinations\n3. **Share** - Version control your `.agents/` directory\n4. **Iterate** - Improve based on usage\n5. **Coordinate agents** - Use `spawnerPrompt` to help other agents understand when to spawn your agent\n","postContent":"---\ntitle: 'Creating New Agents'\nsection: 'advanced'\ntags: ['customization', 'agent templates', 'agents']\norder: 2\n---\n\n# Creating New Agents\nCreate specialized agents from scratch using TypeScript files in the `.agents/` directory.\n\n**Types:**\n\n  - **LLM-based** - Use prompts and language models\n  - **Programmatic** - Use TypeScript generator functions with `handleSteps`\n\n**Control Flow:**\n\n  - `yield 'STEP'` - Run one LLM generation step\n  - `yield 'STEP_ALL'` - Run until completion\n  - `return` - End the agent's turn\n\n**Accessing Context:**\n\n  - `agentState` - Current agent state and message history\n  - `prompt` - User's prompt to the agent\n  - `params` - Additional parameters passed to the agent\n\n## Basic Structure\n\nCreate a new TypeScript file in `.agents/` directory:\n\n**.agents/my-custom-agent.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"my-custom-agent\",\n  version: \"1.0.0\",\n\n\n  displayName: \"My Custom Agent\",\n  spawnerPrompt: \"Spawn this agent for specialized workflow tasks requiring custom logic\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n  toolNames: [\"read_files\", \"write_file\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/researcher@0.0.1\"],  // Use full name for built-in agents\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"What documentation to create or update\"\n    }\n  },\n\n  systemPrompt: `You are a documentation specialist.`,\n  instructionsPrompt: \"Create comprehensive documentation based on the user's request. Research existing code and patterns first.\",\n  stepPrompt: \"Continue working on the documentation. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n\n## Domain-Specific Examples\n\n### API Documentation Agent\n\nSpecialized for documenting REST APIs and GraphQL schemas:\n\n**.agents/api-documenter.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"api-documenter\",\n  version: \"1.0.0\",\n\n\n  displayName: \"API Documentation Specialist\",\n  spawnerPrompt: \"Spawn this agent to create comprehensive API documentation with examples, schemas, and error codes\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\"read_files\", \"code_search\", \"write_file\", \"spawn_agents\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/researcher@0.0.1\"],  // Use full name for built-in agents\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"What API endpoints or schemas to document\"\n    }\n  },\n\n  systemPrompt: \"You are an API documentation specialist. Create clear, comprehensive documentation for REST APIs and GraphQL schemas with examples, request/response formats, and error codes.\",\n  instructionsPrompt: \"Analyze the specified API endpoints and create detailed documentation including examples, parameters, and response schemas.\",\n  stepPrompt: \"Continue documenting the API. Include practical examples and edge cases. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n### Database Migration Agent\n\nSpecialized for creating and reviewing database migrations:\n\n**.agents/migration-specialist.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"migration-specialist\",\n  version: \"1.0.0\",\n\n\n  displayName: \"Database Migration Specialist\",\n  spawnerPrompt: \"Spawn this agent to create safe, reversible database migrations with proper indexing and rollback procedures\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\n    \"read_files\",\n    \"write_file\",\n    \"code_search\",\n    \"run_terminal_command\",\n    \"end_turn\"\n  ],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\"],\n\n  systemPrompt: \"You are a database migration specialist. Your goal is to create safe, reversible database migrations with proper indexing and rollback procedures.\",\n  instructionsPrompt: \"Create a database migration for the requested schema changes. Ensure it's reversible and includes proper indexing.\",\n  stepPrompt: \"Continue working on the migration. Test it if possible and spawn a reviewer to check for issues.\"\n}\n\nexport default definition\n```\n\n## Programmatic Agents (Advanced)\n\n**üéØ This is where Codebuff agents become truly powerful!** While LLM-based agents work well for many tasks, programmatic agents give you precise control over complex workflows, while still letting you tap into LLMs when you want them.\n\n### Why Use Programmatic Agents?\n\n- **Deterministic workflows** - Guarantee specific steps happen in order\n- **Dynamic decision making** - Branch based on your own logic\n- **Complex orchestration** - Coordinate multiple agents and tools with logic\n- **State management** - Maintain state across multiple agent steps\n\n### How It Works\n\nUse TypeScript generator functions with the `handleSteps` field to control execution:\n\n**.agents/code-analyzer.ts**\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"code-analyzer\",\n  displayName: \"Code Analysis Expert\",\n  spawnerPrompt: \"Spawn for deep code analysis and refactoring suggestions\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n\n  toolNames: [\"read_files\", \"code_search\", \"spawn_agents\", \"write_file\"],\n  spawnableAgents: [\"codebuff/thinker@0.0.1\", \"codebuff/reviewer@0.0.1\"],\n\n  handleSteps: function* ({ agentState, prompt, params }) {\n    // First, find relevant files\n    const { toolResult: files } = yield {\n      toolName: 'find_files',\n      input: { query: prompt }\n    }\n\n    // Read the most important files\n    if (files) {\n      const filePaths = JSON.parse(files).slice(0, 5)\n      yield {\n        toolName: 'read_files',\n        input: { paths: filePaths }\n      }\n    }\n\n    // Spawn a thinker for deep analysis\n    yield {\n      toolName: 'spawn_agents',\n      input: {\n        agents: [{\n          agent_type: 'thinker',\n          prompt: `Analyze the code structure and suggest improvements for: ${prompt}`\n        }]\n      }\n    }\n\n    // Let the agent generate its response\n    yield 'STEP_ALL'\n  }\n}\n\nexport default definition\n```\n\n### Key Concepts for Programmatic Agents\n\n#### 1. Generator Function Basics\n\nYour `handleSteps` function receives context and yields actions:\n\n```typescript\nhandleSteps: function* ({ agentState, prompt, params }) {\n  // agentState: Current conversation and agent state\n  // prompt: What the user asked this agent to do\n  // params: Additional parameters passed to the agent\n\n  // Your logic here...\n}\n```\n\n#### 2. Yielding Tool Calls\n\nExecute tools and get their results:\n\n```typescript\nconst { toolResult, toolError } = yield {\n  toolName: 'read_files',\n  input: { paths: ['file1.ts', 'file2.ts'] }\n}\n\nif (toolError) {\n  // Handle error case\n  console.error('Failed to read files:', toolError)\n} else {\n  // Use the result\n  const fileContent = JSON.parse(toolResult)\n}\n```\n\n#### 3. Control Flow Options\n\n**Control Flow:**\n- `yield 'STEP'` - Run one LLM generation step\n- `yield 'STEP_ALL'` - Run until completion\n- `return` - End the agent's turn\n\n#### 4. Advanced Example: Conditional Workflow\n\n```typescript\nhandleSteps: function* ({ agentState, prompt, params }) {\n  // Step 1: Analyze the codebase\n  const { toolResult: analysis } = yield {\n    toolName: 'spawn_agents',\n    input: {\n      agents: [{\n        agent_type: 'thinker',\n        prompt: `Analyze: ${prompt}`\n      }]\n    }\n  }\n\n  // Step 2: Based on analysis, choose action\n  if (analysis?.includes('refactor')) {\n    // Get all files that need refactoring\n    const { toolResult: files } = yield {\n      toolName: 'find_files',\n      input: { query: 'needs refactoring' }\n    }\n\n    // Step 3: Refactor each file\n    for (const file of JSON.parse(files || '[]')) {\n      yield {\n        toolName: 'write_file',\n        input: {\n          path: file,\n          instructions: 'Refactor for better performance',\n          content: '// ... refactored code ...'\n        }\n      }\n    }\n  }\n\n  // Step 4: Final review\n  yield {\n    toolName: 'spawn_agents',\n    input: {\n      agents: [{\n        agent_type: 'reviewer',\n        prompt: 'Review all changes'\n      }]\n    }\n  }\n\n  // Let the agent summarize\n  yield 'STEP_ALL'\n}\n```\n\n### When to Choose Programmatic vs LLM-based\n\n**Use Programmatic (`handleSteps`) when:**\n- You need guaranteed execution order\n- Decisions depend on specific file contents\n- Complex multi-step workflows with branching\n- Integration with external systems\n- Error recovery is critical\n\n**Use LLM-based (prompts only) when:**\n- Task is straightforward\n- Agent needs creative freedom\n- Natural language understanding is key\n- Workflow is simple and linear\n\n```\n**.agents/prompts/doc-writer-system.md**\n}\n\n**.agents/prompts/migration-guidelines.md**\nYou can also reference external files for prompts:\n\n```typescript\nsystemPrompt: {\n  path: \"./prompts/doc-writer-system.md\"\n## Programmatic Agents\n**Coming Soon** - Use JavaScript/TypeScript for complex orchestration logic.\n## Best Practices\n1. **Start small** - Begin with simple agents before complex ones\n2. **Experiment** - Try different tool/prompt combinations\n3. **Share** - Version control your `.agents/` directory\n4. **Iterate** - Improve based on usage\n5. **Coordinate agents** - Use `spawnerPrompt` to help other agents understand when to spawn your agent\n"},{"path":"web/src/content/agents/customizing-agents.mdx","preContent":"---\ntitle: 'Customizing Agents'\nsection: 'advanced'\ntags: ['customization', 'agent templates', 'agents']\norder: 1\n---\n\n# Customizing Agents\n\nCreate specialized agents from scratch using TypeScript files in the `.agents/` directory:\n\n```markdown\n.agents/\n‚îú‚îÄ‚îÄ my-custom-agent.ts\n‚îú‚îÄ‚îÄ security-coordinator.ts\n‚îî‚îÄ‚îÄ types/\n    ‚îî‚îÄ‚îÄ agent-definition.ts\n```\n## Example: Security Coordinator Agent\n\nCreate a specialized agent for security-focused workflows:\n\n**.agents/security-coordinator.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"security-coordinator\",\n  version: \"1.0.0\",\n\n  displayName: \"Security Coordinator\",\n  spawnerPrompt: \"Spawn this agent to coordinate security-focused development workflows and ensure secure coding practices\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\"read_files\", \"spawn_agents\", \"code_search\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\", \"codebuff/researcher@0.0.1\", \"codebuff/file-picker@0.0.1\"],\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"Security analysis or coordination task\"\n    }\n  },\n\n  systemPrompt: \"You are a security coordinator responsible for ensuring secure development practices.\",\n  instructionsPrompt: \"Analyze the security implications of the request and coordinate appropriate security-focused agents.\",\n  stepPrompt: \"Continue analyzing security requirements and coordinating the workflow. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n\n## Advanced: Adding Programmatic Control\n\nMake your agent even more powerful with programmatic control:\n\n```typescript\nconst definition: AgentDefinition = {\n  id: \"security-coordinator\",\n  // ... other fields ...\n  \n  handleSteps: function* ({ prompt, params }) {\n    // 1. Scan for security vulnerabilities\n    const { toolResult: scanResults } = yield {\n      toolName: 'code_search',\n      input: { \n        pattern: '(eval|exec|dangerouslySetInnerHTML|process\\.env)',\n        flags: '-i'\n      }\n    }\n    \n    // 2. If vulnerabilities found, spawn security reviewer\n    if (scanResults) {\n      yield {\n        toolName: 'spawn_agents',\n        input: {\n          agents: [{\n            agent_type: 'security-reviewer',\n            prompt: `Review these potential security issues: ${scanResults}`\n          }]\n        }\n      }\n    }\n    \n    // 3. Let the agent handle the rest\n    yield 'STEP_ALL'\n  }\n}\n```\n\nWith `handleSteps`, your agent can:\n- Make decisions based on actual code analysis\n- Orchestrate multiple tools in sequence\n- Handle errors gracefully\n- Implement complex conditional logic\n\n## Available Fields\n\n**Core:** `id`, `displayName`, `model`, `version`, `publisher`\n**Tools:** `toolNames`, `spawnableAgents`\n**Prompts:** `spawnerPrompt`, `systemPrompt`, `instructionsPrompt`, `stepPrompt`\n**Input/Output:** `inputSchema`, `outputMode`, `outputSchema`, `includeMessageHistory`\n**Programmatic:** `handleSteps`\n\n## Built-in Agents\n\n- `codebuff/base` - Main coding assistant\n- `codebuff/reviewer` - Code review\n- `codebuff/thinker` - Deep thinking\n- `codebuff/researcher` - Research & docs\n- `codebuff/planner` - Planning & architecture\n- `codebuff/file-picker` - File discovery\n\n## Troubleshooting\n\n**Agent not loading:** Check TypeScript syntax, file must export default AgentDefinition\n**Type errors:** Import types from `'./types/agent-definition'`\n**Prompts not applying:** Verify file paths are relative to `.agents/` directory\n\n\n**Debug tips:**\n\n1. Check TypeScript: `bun run typecheck` in `.agents/` directory\n2. Restart Codebuff to see errors\n3. Test with `--agent <agent-id>` to debug specific agents\n**Next:** [Create new agents](/docs/agents/creating-new-agents) or see [troubleshooting guide](/docs/agents#troubleshooting-agent-customization)\n","postContent":"---\ntitle: 'Customizing Agents'\nsection: 'advanced'\ntags: ['customization', 'agent templates', 'agents']\norder: 1\n---\n\n# Customizing Agents\n\nCreate specialized agents from scratch using TypeScript files in the `.agents/` directory:\n\n```markdown\n.agents/\n‚îú‚îÄ‚îÄ my-custom-agent.ts\n‚îú‚îÄ‚îÄ security-coordinator.ts\n‚îî‚îÄ‚îÄ types/\n    ‚îî‚îÄ‚îÄ agent-definition.ts\n```\n\n### Domain-Specific Customization\n\nAgents adapt to your specific workflow and project needs.\n\nKeep in mind you'll get the most value from agents if you see them as a means of managing your context window. Think about how you want to break down tasks and build your agents around that, as opposed to replicating engineering specialties.\n\nComparison: Context managers vs. specialty replicas\n\n<MarkdownTable>\n\n</MarkdownTable>\n\n**Tip:** Use specialty reviewers as spawnable subagents that your context-manager agent calls at the right time in the workflow.\n\n## Example: Security Coordinator Agent\n\nCreate a specialized agent for security-focused workflows:\n\n**.agents/security-coordinator.ts**\n\n```typescript\nimport { AgentDefinition } from './types/agent-definition'\n\nconst definition: AgentDefinition = {\n  id: \"security-coordinator\",\n  version: \"1.0.0\",\n\n  displayName: \"Security Coordinator\",\n  spawnerPrompt: \"Spawn this agent to coordinate security-focused development workflows and ensure secure coding practices\",\n  model: \"anthropic/claude-4-sonnet-20250522\",\n  outputMode: \"last_message\",\n  includeMessageHistory: true,\n\n  toolNames: [\"read_files\", \"spawn_agents\", \"code_search\", \"end_turn\"],\n  spawnableAgents: [\"codebuff/reviewer@0.0.1\", \"codebuff/researcher@0.0.1\", \"codebuff/file-picker@0.0.1\"],\n\n  inputSchema: {\n    prompt: {\n      type: \"string\",\n      description: \"Security analysis or coordination task\"\n    }\n  },\n\n  systemPrompt: \"You are a security coordinator responsible for ensuring secure development practices.\",\n  instructionsPrompt: \"Analyze the security implications of the request and coordinate appropriate security-focused agents.\",\n  stepPrompt: \"Continue analyzing security requirements and coordinating the workflow. Use end_turn when complete.\"\n}\n\nexport default definition\n```\n\n## Advanced: Adding Programmatic Control\n\nMake your agent even more powerful with programmatic control:\n\n```typescript\nconst definition: AgentDefinition = {\n  id: \"security-coordinator\",\n  // ... other fields ...\n\n  handleSteps: function* ({ prompt, params }) {\n    // 1. Scan for security vulnerabilities\n    const { toolResult: scanResults } = yield {\n      toolName: 'code_search',\n      input: {\n        pattern: '(eval|exec|dangerouslySetInnerHTML|process\\.env)',\n        flags: '-i'\n      }\n    }\n\n    // 2. If vulnerabilities found, spawn security reviewer\n    if (scanResults) {\n      yield {\n        toolName: 'spawn_agents',\n        input: {\n          agents: [{\n            agent_type: 'security-reviewer',\n            prompt: `Review these potential security issues: ${scanResults}`\n          }]\n        }\n      }\n    }\n\n    // 3. Let the agent handle the rest\n    yield 'STEP_ALL'\n  }\n}\n```\n\nWith `handleSteps`, your agent can:\n- Make decisions based on actual code analysis\n- Orchestrate multiple tools in sequence\n- Handle errors gracefully\n- Implement complex conditional logic\n\n## Available Fields\n\n**Core:**\n  - `id`\n  - `displayName`\n  - `model`\n  - `version`\n  - `publisher`\n\n**Tools:**\n  - `toolNames`\n  - `spawnableAgents`\n\n**Prompts:**\n  - `spawnerPrompt`\n  - `systemPrompt`\n  - `instructionsPrompt`\n  - `stepPrompt`\n\n**Input/Output:**\n  - `inputSchema`\n  - `outputMode`\n  - `outputSchema`\n  - `includeMessageHistory`\n\n**Programmatic:**\n  - `handleSteps`\n\n\n## Troubleshooting\n\n**Agent not loading:** Check TypeScript syntax, file must export default AgentDefinition\n\n**Type errors:** Import types from `'./types/agent-definition'`\n\n**Prompts not applying:** Verify file paths are relative to `.agents/` directory\n\n**Running specific agents:**\n\n1. Check TypeScript: `bun run typecheck` in `.agents/` directory\n2. Restart Codebuff to see errors\n3. Test with `--agent <agent-id>` to debug specific agents\n"},{"path":"web/src/content/agents/overview.mdx","preContent":"---\ntitle: 'Overview'\nsection: 'agents'\ntags: ['agents', 'multi-agent', 'overview']\norder: 0\n---\n\n# Overview\n\n## Why Multi-Agent Systems Work Better\n\nCodebuff uses specialized agents that collaborate instead of one agent doing everything. Agents spawn other agents, share tools, and pass context between tasks. Here are some of the sub-agents Codebuff uses:\n\n- **Code Generation** - Write clean, functional code\n- **Review** - Catch bugs, security issues, style violations\n- **Research** - Find documentation and examples\n- **Planning** - Break down complex requirements\n- **File Discovery** - Navigate large codebases\n\n## What Makes Codebuff Agents Unique?\n\n> **üí° Key Innovation:** Unlike other AI coding assistants, Codebuff agents can be **programmatically controlled** using TypeScript generator functions. This means you can write actual code to orchestrate complex workflows, make dynamic decisions based on file contents, and ensure deterministic execution paths. It's the difference between hoping an LLM understands your instructions vs. guaranteeing specific behavior.\n\n## Agent Workflow\n\nA typical call to Codebuff may result in the following flow:\n\n```mermaid\nflowchart TD\n    A[User Request] --> B{Task Type}\n\n    B -->|Feature Development| C[Planning Agent]\n    B -->|Bug Investigation| D[Thinker Agent]\n    B -->|Code Refactoring| E[File Picker Agent]\n\n    C --> F[File Picker Agent]\n    D --> G[Research Agent]\n    E --> H[Planning Agent]\n\n    F --> I[Base Agent]\n    G --> I\n    H --> I\n\n    I --> J[Reviewer Agent]\n    J --> K[Complete]\n\n    style A fill:#e1f5fe\n    style I fill:#f3e5f5\n    style J fill:#e8f5e8\n    style K fill:#fff3e0\n```\n\n### Example: Authentication System Refactoring\n\nIf you say \"refactor this authentication system\", Codebuff might break down the task into the following steps:\n\n1. **File Picker** finds auth-related files\n2. **Research** looks up best practices\n3. **Planning** creates step-by-step plan\n4. **Base** implements changes informed by the previous agents\n5. **Reviewer** checks for security issues\n\n### Domain-Specific Customization\n\nAgents adapt to your specific workflow and project needs. You can create specialized agents tailored to your domain or build new ones for unique tasks, like the following:\n\n- **Frontend**: React component reviewer\n- **Backend**: API security reviewer\n- **DevOps**: Infrastructure deployment agent\n\n### Agent Coordination\n\nAgents coordinate through the `spawnerPrompt` field, which helps other agents understand when and why to spawn them. This creates intelligent workflows where:\n\n- Specialized agents are spawned for specific tasks\n- Each agent clearly describes its purpose and capabilities\n- The system automatically matches tasks to the right agents\n\nAgents can spawn other agents listed in their `spawnableAgents` field, creating a hierarchy of specialized helpers.\n\n## Quick Start\n\n1. **[Customize existing agents](/docs/agents#customizing-agents)** - Modify prompts and tools\n2. **[Create new agents](/docs/agents#creating-new-agents)** - Build specialized functionality\n3. **[Reference guide](/docs/agents#agent-reference)** - Complete field documentation\n","postContent":"---\ntitle: 'Overview'\nsection: 'agents'\ntags: ['agents', 'multi-agent', 'overview']\norder: 0\n---\n\n# Overview\n\n## Why Multi-Agent Systems Work Better\n\nCodebuff uses specialized agents that collaborate instead of one agent doing everything. Agents spawn other agents, share tools, and pass context between tasks. Here are some of the sub-agents Codebuff uses:\n\n- **Code Generation** - Write clean, functional code\n- **Review** - Catch bugs, security issues, style violations\n- **Research** - Find documentation and examples\n- **Planning** - Break down complex requirements\n- **File Discovery** - Navigate large codebases\n\n## What Makes Codebuff Agents Unique?\n\nCodebuff agents can be **programmatically controlled** using TypeScript generator functions. You can write actual code to orchestrate complex workflows, make decisions based on file contents, and add in determinism as you see fit. Instead of hoping an LLM understands your instructions you can guarantee specific behavior.\n\n## Built-in Agents\n\n- `codebuff/base` - Main coding assistant\n- `codebuff/reviewer` - Code review\n- `codebuff/thinker` - Deep thinking\n- `codebuff/researcher` - Research & docs\n- `codebuff/planner` - Planning & architecture\n- `codebuff/file-picker` - File discovery\n\n## Agent Workflow\n\nA typical call to Codebuff may result in the following flow:\n\n```mermaid\nflowchart TD\n    A[User Request] --> B{Task Type}\n\n    B -->|Feature Development| C[Planning Agent]\n    B -->|Bug Investigation| D[Thinker Agent]\n    B -->|Code Refactoring| E[File Picker Agent]\n\n    C --> F[File Picker Agent]\n    D --> G[Research Agent]\n    E --> H[Planning Agent]\n\n    F --> I[Base Agent]\n    G --> I\n    H --> I\n\n    I --> J[Reviewer Agent]\n    J --> K[Complete]\n\n    style A fill:#e1f5fe\n    style I fill:#f3e5f5\n    style J fill:#e8f5e8\n    style K fill:#fff3e0\n```\n\n### Example: Authentication System Refactoring\n\nIf you say \"refactor this authentication system\", Codebuff might break down the task into the following steps:\n\n1. **File Picker** finds auth-related files\n2. **Research** looks up best practices\n3. **Planning** creates step-by-step plan\n4. **Base** implements changes informed by the previous agents\n5. **Reviewer** checks for security issues\n\n### Agent Coordination\n\nAgents coordinate through the `spawnerPrompt` field, which helps other agents understand when and why to spawn them. This creates intelligent workflows where:\n\n- Specialized agents are spawned for specific tasks\n- Each agent clearly describes its purpose and capabilities\n- The system automatically matches tasks to the right agents\n\nAgents can spawn other agents listed in their `spawnableAgents` field, creating a hierarchy of specialized helpers.\n\n## Quick Start\n\n1. **[Customize existing agents](/docs/agents#customizing-agents)** - Modify prompts and tools\n2. **[Create new agents](/docs/agents#creating-new-agents)** - Build specialized functionality\n3. **[Reference guide](/docs/agents#agent-reference)** - Complete field documentation\n"}]}